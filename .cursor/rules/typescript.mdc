# TypeScript Rules for Camply Project

## Type Definitions

### Database Types Location

- All database-related types in `src/types/database.ts`
- Import types consistently: `import type { TypeName } from '@/types/database'`

### Required Type Exports

```typescript
// Core database interfaces
export interface User { ... }
export interface College { ... }
export interface UserAcademicDetails { ... }
export interface UserFormData { ... }
export interface UserStatus { ... }

// Additional types as needed
export interface DepartmentData { ... }
```

### UUID Handling

- All database IDs are strings (UUID format)
- Never use number types for database IDs
- Optional IDs use `id?: string` pattern

## Import/Export Consistency Rules

### Global Import Patterns

```typescript
// ✅ Always use @/ for global imports
import { cn } from "@/lib/utils";
import { supabase } from "@/lib/supabase";
import type { User, College } from "@/types/database";
import { Button, Input } from "@/components/ui";
import { useUserData } from "@/hooks/useUserData";

// ❌ Never use relative paths for global utilities
import { cn } from "../../../../lib/utils"; // WRONG
import { supabase } from "../../../lib/supabase"; // WRONG
```

### Feature-Specific Import Patterns

```typescript
// ✅ Use relative imports within same feature/view
import { ComponentName } from "./components/ComponentName";
import { useLocalHook } from "../hooks/useLocalHook";
import type { LocalType } from "../types/local";

// ✅ Mixed example - global + feature imports
import { cn } from "@/lib/utils"; // Global utility
import type { User } from "@/types/database"; // Global type
import { LocalComponent } from "./components/LocalComponent"; // Same view
```

### Import Order Standards

```typescript
// 1. React & external library imports
import { useState, useEffect } from "react";
import { motion } from "framer-motion";

// 2. Global absolute imports (@/)
import { cn } from "@/lib/utils";
import { supabase } from "@/lib/supabase";
import type { User } from "@/types/database";
import { Button } from "@/components/ui";

// 3. Feature/view relative imports
import { LocalComponent } from "./components/LocalComponent";
import { useLocalHook } from "../hooks/useLocalHook";
import type { LocalType } from "../types/local";
```

### Index File Utilization

```typescript
// ✅ Always use index files for UI components
import { Button, Input, Card } from "@/components/ui";

// ❌ Never direct import UI components
import { Button } from "@/components/ui/button"; // WRONG

// ✅ Use index files for grouped exports
import { database, supabase } from "@/lib";
import type { User, College } from "@/types";
```

## Supabase Integration

### Client Usage

```typescript
import { supabase } from "@/lib/supabase";

// Always specify return types
const { data, error }: { data: Type[] | null; error: any } = await supabase
  .from("table_name")
  .select("columns");
```

### Error Handling Pattern

```typescript
if (error && error.code !== "PGRST116") {
  throw error;
}
```

### Query Response Types

- Use Supabase's generated types when possible
- Fallback to custom interfaces for complex queries
- Always handle null data responses

## Form Handling

### Form Data Types

```typescript
// Form state should match UserFormData interface
const [formData, setFormData] = useState<UserFormData>({
  // Initial values with proper types
});

// Event handlers with proper typing
const handleChange = (
  e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>
) => {
  const { name, value, type } = e.target;
  setFormData((prev) => ({
    ...prev,
    [name]: type === "number" ? parseInt(value) || 0 : value,
  }));
};
```

### Async Function Types

```typescript
// Database operations
export const functionName = async (param: ParamType): Promise<ReturnType> => {
  // Implementation
};

// Form submission handlers
const handleSubmit = async (formData: UserFormData): Promise<void> => {
  // Implementation
};
```

## React Component Types

### Component Props

```typescript
interface ComponentProps {
  onSubmit: (data: UserFormData) => Promise<void>;
  loading: boolean;
  error: string | null;
  initialData?: Partial<UserFormData>; // Use Partial for optional initial data
}

const Component = ({
  onSubmit,
  loading,
  error,
  initialData,
}: ComponentProps) => {
  // Implementation
};
```

### Hook Return Types

```typescript
export const useCustomHook = (param: ParamType) => {
  // State with explicit types
  const [state, setState] = useState<StateType>(initialValue);

  // Return object with consistent typing
  return {
    state,
    loading: boolean,
    error: string | null,
    actions: {
      actionName: (param: ParamType) => Promise<ReturnType>,
    },
  };
};
```

## Error Handling Types

### Error Response Pattern

```typescript
interface ErrorResponse {
  message: string;
  code?: string;
  details?: any;
}

// Error handling in try-catch
try {
  const result = await databaseOperation();
  return result;
} catch (err) {
  const errorMessage = err instanceof Error ? err.message : "Unknown error";
  throw new Error(errorMessage);
}
```

## File Organization & Exports

### Index File Patterns

```typescript
// src/components/index.ts
export { default as SimpleLoader } from "./SimpleLoader";
export * from "./sidebar";
export * from "./ui";

// src/lib/index.ts
export { supabase } from "./supabase";
export { cn } from "./utils";
export * from "./database";

// src/types/index.ts
export type * from "./database";
export type * from "./global";
```

### Component Export Standards

```typescript
// ✅ Default export for main component
const ComponentName = ({ props }: ComponentProps) => {
  return <div>...</div>;
};

export default ComponentName;

// ✅ Named exports for sub-components or utilities
export { SubComponent, helperFunction };
```

## Strict Type Checking Rules

### No `any` Types

- Avoid `any` except for Supabase error objects (temporary)
- Use `unknown` for truly unknown types
- Create specific interfaces for complex objects

### Null Safety

```typescript
// Handle potential null/undefined values
const value = data?.property || defaultValue;

// Use optional chaining consistently
user?.academic_id && doSomething();

// Proper null checks for database responses
if (userData && userData.length > 0) {
  // Process data
}
```

### Type Guards

```typescript
const isValidUser = (user: any): user is User => {
  return (
    user &&
    typeof user.user_id === "string" &&
    typeof user.name === "string" &&
    typeof user.email === "string"
  );
};
```

## Generic Types

### API Response Wrapper

```typescript
interface ApiResponse<T> {
  data: T | null;
  error: string | null;
  loading: boolean;
}

// Usage
const userResponse: ApiResponse<User> = await getUserData();
```

### Reusable Form Types

```typescript
type FormField<T> = {
  value: T;
  error?: string;
  required?: boolean;
};

interface FormState<T> {
  [K in keyof T]: FormField<T[K]>;
}
```

## Documentation Requirements

### Function Documentation

```typescript
/**
 * Creates a new user with academic details
 * @param userId - UUID of the authenticated user
 * @param email - User's email address
 * @param formData - Academic form data
 * @returns Promise resolving to user and academic details
 * @throws Error if creation fails
 */
export const createUserWithAcademicDetails = async (
  userId: string,
  email: string,
  formData: UserFormData
): Promise<{ user: User; academicDetails: UserAcademicDetails }> => {
  // Implementation
};
```

### Interface Documentation

```typescript
/**
 * Represents a college/university in the system
 */
interface College {
  /** UUID primary key */
  college_id: string;
  /** Official name of the institution */
  name: string;
  /** City where college is located */
  city?: string;
  /** State where college is located */
  state?: string;
  /** Parent university name */
  university_name?: string;
}
```

## Linting & Formatting

### Required ESLint Rules

```json
{
  "@typescript-eslint/no-unused-vars": "error",
  "@typescript-eslint/explicit-function-return-type": "warn",
  "@typescript-eslint/no-explicit-any": "warn",
  "@typescript-eslint/prefer-nullish-coalescing": "error"
}
```

## Performance Considerations

### Lazy Loading Types

```typescript
// Use React.lazy for component code splitting
const LazyComponent = React.lazy(() => import("./Component"));

// Use dynamic imports for large type definitions
type LargeType = import("./types/large").LargeType;
```

### Memoization with Types

```typescript
const memoizedValue = useMemo<ComputedType>(() => {
  return expensiveComputation(data);
}, [data]);

const memoizedCallback = useCallback<(param: ParamType) => void>(
  (param) => {
    // Callback implementation
  },
  [dependency]
);
```
